<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">




				<section>
					<p>Object Oriented concepts  </p>
	    		<p class="fragment fade-up"> what is Object?</p>
					<p class="fragment fade-up"> 1. Attributes: data/fields/properties </p>
					<p class="fragment fade-up"> 2. Behavior:  Procedures/methods </p>
					<p class="fragment fade-up"> Examples : Pen, Duster , Person , Employee  </p>
					<p class="fragment fade-up"> what is <a href="https://en.wikipedia.org/wiki/Object-oriented_programming#Objects_and_classes" >Object oriented </a> ?</p>
					<p class="fragment fade-up"> one of <a href="https://en.wikipedia.org/wiki/Programming_paradigm">Programming paradigm</a> </p>
					<p class="fragment fade-up"> Programming: procedural (2nd) : Object-oriented(3rd) </p>

				</section>

				<section>  Features / Characteristics of Object Oriented
						<ul>
							<li class="fragment fade-up"> Object Composition </li>
							<li class="fragment fade-up"> Inheritance </li>

							<li class="fragment fade-up"> Encapsulation: information hiding , strong form of abstraction (method implementation) detail hiding </li>
							<li class="fragment fade-up"> Polymorphism </li>
							<li class="fragment fade-up"> Dynamic dispatch | message passing </li>
							<li class="fragment fade-up"> Open recursion:  use this or self to invoke same level method or property</li>
						</ul>
						<p class="fragment fade-up"> letâ€™s look at object in JavaScript</p>
				</section>



				<section>
					Object : one of the data type in JS

						<pre class="fragment fade-up">
Create a new object
<code class="hljs js" data-trim contenteditable>
var o = { "a" : "value a"};

// Example of an object property added with defineProperty with a data property descriptor

var obj = {};

obj.a = 1;
// is equivalent to:
Object.defineProperty(obj, 'a', {
  value: 1,
  writable: true,
  configurable: true,
  enumerable: true
});
// so we can perform any action we want


// On the other hand,
Object.defineProperty(obj, 'a', { value: 1 });
//  immutable and is equivalent to:
Object.defineProperty(obj, 'a', {
  value: 1,
  writable: false,
  configurable: false,
  enumerable: false
});

// property and method
var obj = {
	"key1" : "value of key1",
	"method1" : function (){
		console.log("output in console window from method1 this method of object can be overwrtiiten");
	}
}
obj.key2 = "value from key2"
obj.method2 = function (){
	console.log("output in console window from method2 this method of object can be overwrtiiten");
}

Object.defineProperty(obj, 'method3', {
  value: function(){ console.log("output in console window from method3.  this could be not overwrtiiten") },
  writable: false,
  configurable: false,
  enumerable: false
});

							</code>
						</pre>


				</section>



				<section>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">property type</a>
					<p class="fragment fade-up">
						writable :  true =  can change ,  false = no change
					</p>
					<p class="fragment fade-up">
						enumerable : true =  Object.keys(o) or for...in loop ,
					</p>
					<p class="fragment fade-up">
						configurable : The configurable attribute controls at the same time whether the property can be deleted from the object and whether its attributes (other than writable) can be changed.
					</p>
					<p class="fragment fade-up">
					 so, ( writable , configurable ) are property one shloud care about
					</p>
</section>
<section>
enumerable and prototype chain sequnce
					<p class="fragment fade-up">

 							<ul><a target="_blank" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">Detection Table</a>
							<li>Object.keys() : hasOwnProperty and only enumerable properties  </li>
							<li>Object.getOwnPropertyNames()  : hasOwnProperty   </li>
							<li>for...in loop : all keys but only enumerable properties </li>
							<li>in  : iterate over full prototype chain and return  key is in object even from inhertaed objects</li>
							</ul>
					<p>
					<!-- <p class="fragment fade-up">
						main data-type in javascript that is Object is coverd now it time for separate function/method/procedure
					</p> -->

					</section>

	<section>

			<h5>Function for method</h5>

			<p class="fragment fade-up">
			 If the first token in a statement is function, then it is a function	statement.
			</p>
<pre class="fragment fade-up">
1. function as statement
<code class="hljs js" data-trim contenteditable>

function hello(){
console.log("hello from function method")

}
hello()
</code>
</pre>
<pre class="fragment fade-up">
2. function as expression
<code class="hljs js" data-trim contenteditable>

var hello = function optionalname(){

console.log("hello  from expression function");

}
// optionalname() will not work
hello();
</code>
</pre>

		</section>

	<section>
		lets see some hidden part of function

		<p class="fragment fade-up">
			some default parameters which are not passed but available in function whlie a function is invoked
		</p>
		<ol>
			<li class="fragment fade-up"> arguments
				<ul>
					<li>It contains all of the arguments from the invocation.</li>
					<li>It is an array-like object.</li>
				</ul>
			</li>
			<li class="fragment fade-up"> this
				<ul>
					<li>The this parameter contains a reference to the object of invocation.</li>
					<li>i.e allows a method to know what object it is concerned with.</li>
				</ul>
			</li>
		</ol>
		</section>
		<section>Example

<pre class="fragment fade-up">

<code class="hljs js" data-trim contenteditable>

function hello(){
console.log("hello from function method")
console.log(this);
console.log(arguments)
}

</code>
// expands to
// var hello = function hello() {};
// which further expands to
// var hello = undefined;
// hello = function hello() {};

// so hello() = window.hello()
</pre>

		</section>
		<section>  Function arguments
			<ul>
				<li>If a function is called with too many arguments, the extra arguments are ignored.</li>
				<li>If a function is called with too few arguments, the missing values will be undefined </li>
				<li>There is no implicit type checking on the arguments.</li>

			</ul>
		</section>
		<section>
<!--
since of "arguments" and "this" are avialbele as special parameters in fucntion block after incvocation(calling) fucntion
<br>
<br> -->

<b> ways of invoking (calling) function are below</b>
<ol>
<li> Simple procedureal method || ()
<li> Constructor with new operator|| new
<li> apply or call
</ol>
</section>



	<section>1. simple procedureal method
<br>
default return is undefined
<pre class="fragment fade-up">

<code class="hljs js" data-trim contenteditable>
function person(fname,lname){

		console.log(fname);
		console.log(lname);
		this.fname = fname;
		this.lname = lname;
}
person() = window.person();

// window.fname
// window.lname

</code>
</pre>
<ul class="fragment fade-up">
<li>so in this simple invocation only single instance(object) is attached and so it's property get replaced
<li>what to do to have separate property for separate thing(object) i.e separate object instance
</ul>
</section>
<section>
2. Constructor
<br> default return is this
<pre class="fragment fade-up">

<code class="hljs js" data-trim contenteditable>

function Person(fname,lname){
		this.fname = fname
		this.lname = lname

}

var p1 = new Person("abc","xyz");
var p2 = new Person("AAA","ZZZ");

// we have now two separate instance p1 and p2 ...so instance of (blue print) class is covered
// object can have method/behaviour as well as fields/attribute

// so lets define some method of blue print

function Person(fname,lname){
		this.fname = fname
		this.lname = lname
		this.fullname = function (){
				console.log("my full name is " + this.fname + this.lname )
		}
}

var p1 = new Person("abc","xyz");
var p2 = new Person("AAA","ZZZ");

console.log(p1);
console.log(p2);
</code>
</pre>
</section>
<section>
 methods/behaviour are diffrent for same type Class
	<br>not everytime right?
<br>
<br>
so this kind of blue printing - object creation is wrong
<br>because it create more memory and why to create more memory for same thing
<br>
<br>
so what is solution ?
<br>
ans  : LINKING to comman place
</section>
<section>
<h3>introducing prototype : interface </h3>
object type property of instance
<pre class="fragment fade-up">
<code class="hljs js" data-trim contenteditable>
function Person(fname,lname){
		this.fname = fname
		this.lname = lname

}

Person.prototype.fullname = function (){
console.log("my full name is " + this.fname + this.lname )
}
var p1 = new Person("abc","xyz");
var p2 = new Person("AAA","ZZZ");

console.log(p1);
console.log(p2);
</code>
</pre>
<div class="fragment fade-up">
class (blue print) - instance (object ) creation  and  interface design ( abstract class ) complete
<br>
interface everything is public while need some thing as private solution is abstract class
<br>

</div>
</section>
<!--

 -->

<section>
but still inheritance is missing


<pre class="fragment fade-up">example
<code class="hljs js" data-trim contenteditable>

function Person(fname,lname){
		this.fname = fname
		this.lname = lname
}

function Employee(fname,lname,desgination){
		this.fname = fname
		this.lname = lname
		this.desgination = desgination
}

</code>
but Employee is Person so why to recode that
</pre>
<h3 class="fragment fade-up">indroducing inhertahnce</h3>

</section>
<section>
		Inheritance type
<br>
<ul class="fragment fade-up">
<li>Pseudoclassical Inheritance</li>
<li>Prototypal Inheritance</li>
</ul>
<pre class="fragment fade-up">
Pseudoclassical Inheritance

<code class="hljs js" data-trim contenteditable>


function Person(fname,lname){
		this.fname = fname
		this.lname = lname

}

Person.prototype.walk = function(){
  console.log("I am walking!");
};
Person.prototype.run = function(){
  console.log("I am running by !");
};


function Employee(fname,lname,desgination){

		Person.call(this, fname,lname);
		// same as extend class in java
		// multiple inhertinace in java is not posssilbe directly
		// multiple inhertinace in js posssible sequnce matter as in c languuage
		this.desgination = desgination

}
Employee.prototype.profile = function(){
	console.log("i am " + this.fname + " at desgiantion " + this.desgination  )
}

var e1 = new Employee("xxx","yyy","zzz");

</code>
// e1.walk() or e1.run() not available
</pre>

</section>
<section>
<h5>Prototypal Inheritance</h5>


still we can not access prototype method of parent class

<pre class="fragment fade-up">

<code class="hljs js" data-trim contenteditable>
function Person(fname,lname){
		this.fname = fname
		this.lname = lname
}

Person.prototype.walk = function(){
  console.log("I am walking!");
};

Person.prototype.run = function(){
  console.log("I am running by !");
};

function Employee(fname,lname,desgination){
		Person.call(this, fname,lname);
		this.desgination = desgination
}

Employee.prototype.profile = function(){
	console.log("i am " + this.fname + " at desgiantion " + this.desgination  )
}

Employee.prototype =  Object.create(Person.prototype);
// implement interface in java
// multiple interface in java possible
// multiple interface in js not possible

Employee.prototype.profile2 = function(){
	console.log("i am " + this.fname + " at desgiantion " + this.desgination  )
}

var e1 = new Employee("xxx","yyy","zzz");

</code>
Object.create() is prototypal Inheritance
defination of prototypal Inheritance :
If we replace the original prototype object, then we can inherit another object's stuff.
</pre>

</section>
<section>
everything is okay but e1 "constructor" is wrong so <br>
Set the "constructor" property to refer to Employee
<pre class="fragment fade-up">

<code class="hljs js" data-trim contenteditable>
Employee.prototype.constructor = Employee


</code>

</pre>

</section>
<section>

		inheritance type : based on approach of inheritance
		<p class="fragment fade-up">1. Class-based : JAVA : composition</p>
		<p class="fragment fade-up">2. Prototype-based  : Javascript : linking</p>
		<p class="fragment fade-up"> Related classification : composition , linking</p>

</section>
<section>


<ul>Function objects are first class object
<li>May assigned to a variable
<li>May be stored in an object or array
<li>May be passed as an argument to a function
<li>May be returned from a function
</ul>

</section>
<section>
inheritance .... with example
<pre class="fragment fade-up">

<code class="hljs js" data-trim contenteditable>

var o1 = {};
o1.a = 1;

Object.defineProperty(o1, 'b', {
  value: 'b1',
  writable: false,
  configurable: false,
  enumerable: false
});

var o2 =  Object.create(o1);
console.log(o2);
console.log(o2.b);

o2.a = 23;
console.log(o2);


</code>

</pre>
</section>
<section>
bug 1
<pre class="fragment fade-up">

<code class="hljs js" data-trim contenteditable>

var o1 = {};
o1.a = 1;

Object.defineProperty(o1, 'b', {
  value: 'hello b',
  writable: false,
  configurable: false,
  enumerable: false
});

var o2 =  Object.create(o1);
console.log(o2);
console.log(o2.b);

o2.a = 23;
console.log(o2.a);

delete o2.a
// magic begins
console.log(o2.a);





</code>
alwyas try to keep only methods in parent object if using  inhertiance
</pre>
</section>
<section>
misconcept
<pre class="fragment fade-up">

<code class="hljs js" data-trim contenteditable>
function Person(fname,lname){
		this.fname = fname
		this.lname = lname
		this.hellomethod =  function(){
			console.log("hello from mehtod")
		}
}

Person.prototype.walk = function(){
  console.log("I am walking!");
};

Person.prototype.run = function(){
  console.log("I am running by !");
};

function Employee(fname,lname,desgination){
		this.fname = fname
		this.lname = lname
		this.desgination = desgination
}
// bug
Employee.prototype = new Person();

</code>
// never use new for inheritance
</pre>

</section>

<section>

<a href="jquery-event.html" target="_blank" > event delgation</a>



</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					//{ src: './plugin/externalcode/externalcode.js', condition: function() { return !!document.querySelector( '[data-code]' ); } },
				]
			});

			 RevealEditor({
        aceTheme: "ace/theme/twilight",
        javascript: true,
        html: true,
        css: true,
        fontSize: 18
    });

		</script>
	</body>
</html>
